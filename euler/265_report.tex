\documentclass[11pt]{article}

\usepackage{epsf,amsfonts,amssymb,hyperref}

\begin{document}
\title{Solution to Project Euler problem \#265}
\author{Lev A Neiman}

\maketitle

\section{Problem Statement}

2N binary digits can be placed in a circle so that all the N-digit clockwise subsequences are distinct.

For N=3, two such circular arrangements are possible, ignoring rotations - 00010111, 00011101.

For the first arrangement, the 3-digit subsequences, in clockwise order, are:
000, 001, 010, 101, 011, 111, 110 and 100.

Each circular arrangement can be encoded as a number by concatenating the binary digits starting with the subsequence of all zeros as the most significant bits and proceeding clockwise. The two arrangements for N=3 are thus represented as 23 and 29:

00010111 = 23
00011101 = 29
Calling S(N) the sum of the unique numeric representations, we can see that S(3) = 23 + 29 = 52.

Find S(5).

\section{Solution}

I have used simple DFS with branch pruning that runs under a second.  DFS simply tries all possibilities and checks if they contain no overlapping subssequences of size N.  When it reaches solution of size $ 2^{N} $ it adds it to accumulator if such solution is good.  When solution is smaller the search tries to add '0' and '1' to current solution.  If resulting string contains equal subsequences of size N then it does not take that branch.  

\section{Analysis}

Running time is exponential with respect to N.  More precisely the upper limit is $ O(2^{2^{N}}) $ as there are $ 2^{2^{N}} $ possible strings.  Majority of them can be pruned off, however, but it does not really improve the asymptotic complexity, but is enough to solve it for small $ N = 5 $ since $ 2^{2^{5}} = 4,294,967,296 $.  After pruning most of the bad branches this number reduces drastically so we can solve whole problem under a second.  Counting the number recursive DFS function is called I get $ 84,444 $ which is pretty manageable.  

\end{document}
